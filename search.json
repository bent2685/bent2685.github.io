[{"title":"宝藏镜像源管理工具","url":"/2024/10/23/宝藏镜像源管理工具/","content":"\n> 平时开发时用到的许多环境、命令、工具都会涉及到镜像源的问题，因为网络环境的不同，每个网络所适合的镜像源也不同，甚至会直接ping不通...\n\n## TL;DR\n\n直达[**chsrc官方仓库**]( https://github.com/RubyMetric/chsrc)\n\n---\n\n## chsrc介绍\n\n> 引用官方: 全平台通用换源工具与框架 **[chsrc](https://gitee.com/RubyMetric/chsrc)**，**目标支持 Linux, Windows (MSYS2, Cygwin), macOS, BSD 等尽可能多的操作系统环境，龙芯、飞腾、RISC-V 等尽可能多的 CPU**。\n>\n> 我们使用 **C99** 来完成上述目标。我们并不使用 Python 或 JS 等解释语言，因为一个简单的换源工具，不应该强行塞给用户一个庞大的解释器和数十、数百 MB 其他文件。\n>\n> chsrc官方仓库: https://github.com/RubyMetric/chsrc\n\n使用这个工具可以很方便的**实现换镜像源的操作**，它支持大多数软件、环境、编程语言、操作系统例如: pip、node(npm、yarn、pnpm)、java、go、rust、docker...\n\n更多支持情况请使用`chsrc list`命令来查看。\n\n---\n\n## chsrc安装\n\n这边只对`Mac`和`Linux`展开介绍\n\n### Mac平台安装\n\n> 前提安装了[Homebrew](https://brew.sh/)\n\n```bash\nbrew install chsrc\n```\n\n-- 完成\n\n---\n\n### Linux平台安装\n\n> 在合适的目录下根据系统价格执行对应的`curl`命令\n\n```bash\n# x64\ncurl -L https://gitee.com/RubyMetric/chsrc/releases/download/pre/chsrc-x64-linux -o chsrc; chmod +x ./chsrc\n\n# aarch64\ncurl -L https://gitee.com/RubyMetric/chsrc/releases/download/pre/chsrc-aarch64-linux -o chsrc; chmod +x ./chsrc\n\n# riscv64\ncurl -L https://gitee.com/RubyMetric/chsrc/releases/download/pre/chsrc-riscv64-linux -o chsrc; chmod +x ./chsrc\n\n# armv7\ncurl -L https://gitee.com/RubyMetric/chsrc/releases/download/pre/chsrc-armv7-linux -o chsrc; chmod +x ./chsrc\n```\n\n接着，需要给`./chsrc`设置环境变量或者别名\n\n- 打开`/etc/profile`\n\n  ```bash\n  vim /etc/profile\n  ```\n\n- 在末尾添加\n\n  ```bash\n  export PATH=$PATH:{chsrc所在目录}\n  # 例如: export PATH=$PATH:/home/user1/tools\n  ```\n\n- 或者设置别名\n\n  ```bash\n  alias chsrc='/home/user1/tools/chsrc'\n  ```\n\n- 最后保存后需要执行\n\n  ```bash\n  source /etc/profile\n  ```\n\n-- 完成\n\n---\n\n## chsrc使用\n\nchsrc的使用特别简单，具体请看官方仓库示例。这边举一个给docker换源的例子:\n\n```bash\nchsrc set docker\n```\n\n![image-20241023111133027](../images/宝藏镜像源管理工具.assets/image-20241023111133027.png)\n\n可以看到chsrc会自动选择当前网络环境下最快的镜像源\n\n---\n\n分享就到这里了，就这样吧。\n\n# 👌 回见;\n","tags":["工具推荐"]},{"title":"Vite + Axios跨域问题","url":"/2024/06/11/Vite + Axios跨域问题/","content":"\n> 跨域问题指的是不同站点之间，使用 ajax 无法相互调用的问题。跨域问题本质是浏览器的一种保护机制，它的初衷是为了保证用户的安全，防止恶意网站窃取数据。但这个保护机制也带来了跨域问题。\n\n---\n\n## 跨域的定义\n\n在请求时，如果出现了以下情况中的任意一种，那么它就是跨域请求：\n\n1. **协议不同, 如 http 和 https**\n2. **域名不同**\n3. **端口不同**\n\n---\n\n## 解决方式\n\n### 后端解决(⭐️⭐️⭐️⭐️⭐️)\n\n什么？后端不愿意解决？那就接着往下看。\n\n---\n\n### Nginx反代(⭐️⭐️⭐️⭐️⭐️)\n\n在上生产环境时，可以使用nginx来做反向代理，从而也可以解决跨域。这也是一种比较推荐的方式，但是今天在这就不讨论了。\n\n---\n\n### 前端解决\n\n如果后端死都不愿意解决，那就到了我们今天的主题**Vite + Axios通过代理解决跨域问题**\n\n> TIPS: 不过这种方式只能在开发环境使用，生产环境会失效\n\n在`vite.config.ts/js`里加入如下配置\n\n它的作用就是通过配置代理表将请求的目标地址设为代理服务器的地址, 例如将请求的基础url设置为`/api`，当浏览器发送请求时会先将请求发送到代理服务器然后再由代理服务器转发给目标服务器，从而绕过同源策略的限制。\n\n```typescript\nserver: {\n  proxy: {\n    '/api': {\n      target: 'http://接口主机地址:8080',\n      secure: false,\n      changeOrigin: true, //this one is declare for cross\n      rewrite: path => {\n        console.log(`网络请求: ${path.replace('/api', '')}`)\n        return path.replace(/^\\/api/, '')\n      }\n    }\n  }\n}\n```\n\n然后修改axios的基本配置\n\n```typescript\n// 创建axios实例\nconst serve: AxiosInstance = axios.create({\n  baseURL: '/api',\n  timeout: 10000\n})\n```\n\n---\n\n## 文末;\n\n没啥好总结的\n\n---\n\n# 👌 加纳~;\n","tags":["技术分享","前端"]},{"title":"刷新.gitignore更改","url":"/2024/05/22/刷新.gitignore更改/","content":"\n> **前情提要:**\n>\n> 当我们更新了gitignore后，接下来想stash和commit的时候，发现声明的忽略文件还是会出现在的更改区中。\n\n## TL;DR\n\n```sh\ngit rm -r --cached . # 删除本地缓存\ngit add . # 添加要提交的文件\ngit commit -m 'update .gitignore' # 更新本地的缓存\n```\n\n---\n\n## 解决方案\n\n其实，只需要我们把缓存清理下\n\n```sh\ngit rm -r --cached .\n```\n\n再重新把所有更改文件添加到暂存区即可\n\n```sh\ngit add .\n```\n\n最后再commit文件\n\n```sh\ngit commit -m 'update .gitignore' \n```\n\n最后，如果有remote origin。那就执行`git pull & git push`把更改和remote同步。\n\n---\n\n## 更多方式\n\n**「接下来是安利环节」**\n\n在MacOS中，有一个git GUI叫[fork](https://git-fork.com/)。fork是一款特别出色的git可视化工具，它在commit节点预览、合并、变基、和远端remote、代码的diif......这些领域都做的非常好。当然在右键将文件ignore时，他也会自动刷新更改区。\n\n其他的git GUI我没使用过，无法再推荐更多了。实际上很多IDE也可以通过插件的方式去实现这个功能。\n\n![Fork](https://git-fork.com/images/image1.jpg)\n\n> **相关链接:**\n>\n> - **Fork:** https://git-fork.com/\n\n---\n\n# 👋 ;\n","tags":["技术分享"]},{"title":"CSS BEM命名规范","url":"/2024/05/21/CSS BEM命名规范/","content":"\n> BEM（Block, Element, Modifier）是一种命名规范，用于创建可维护和可重用的 CSS 代码。它通过将 CSS 类名组织成独立的块、元素和修饰符，使代码更具结构性和一致性。\n\n## BEM 的基本概念\n\n1. **块（Block）**：页面中独立存在的功能性块，块可以包含元素和修饰符。块的命名是唯一的，并且不依赖于页面的其他部分。\n2. **元素（Element）**：块的一部分，完成某项具体功能。元素的命名依赖于块，表示为块名后加双下划线和元素名。\n3. **修饰符（Modifier）**：用于定义块或元素的不同状态或外观。修饰符的命名依赖于块或元素，表示为块名或元素名后加双横线和修饰符名。\n\n---\n\n## BEM 命名规则\n\n- 块（Block）：`.block`\n- 元素（Element）：`.block__element`\n- 修饰符（Modifier）：`.block--modifier` 或 `.block__element--modifier`\n\n---\n\n## 示例\n\n以下是一个使用 BEM 命名规范的示例：\n\n```html\n<div class=\"button button--primary\">\n  <span class=\"button__text\">Click Me</span>\n</div>\n```\n\n在这个例子中：\n\n- `button` 是一个块，表示按钮。\n- `button__text` 是块 `button` 的一个元素，表示按钮的文本。\n- `button--primary` 是块 `button` 的一个修饰符，表示按钮的主要样式。\n\n---\n\n## 详细说明\n\n### 块（Block）\n\n块是页面中独立存在的功能性单元。块名应该简洁、描述性强，通常是一个名词。例如：\n\n```html\n<div class=\"header\"></div>\n<div class=\"menu\"></div>\n<div class=\"footer\"></div>\n```\n\n---\n\n### 元素（Element）\n\n元素是块的一部分，用于完成某项具体功能。元素名应该紧跟块名，用双下划线 `__` 分隔，通常是名词或形容词。例如：\n\n```html\n<div class=\"menu\">\n  <div class=\"menu__item\"></div>\n  <div class=\"menu__link\"></div>\n</div>\n```\n\n---\n\n### 修饰符（Modifier）\n\n修饰符用于定义块或元素的不同状态或外观。修饰符名应该紧跟块名或元素名，用双横线 `--` 分隔，通常是形容词或描述状态的词语。例如：\n\n```html\n<div class=\"button button--large\"></div>\n<div class=\"button button--disabled\"></div>\n<div class=\"menu__item menu__item--active\"></div>\n```\n\n---\n\n## BEM 的优点\n\n1. **可读性**：通过明确的命名规则，使 CSS 类名更具描述性和一致性，便于理解和维护。\n2. **可重用性**：通过将块、元素和修饰符分离，使组件更易于重用。\n3. **可维护性**：通过将样式拆分成独立的块、元素和修饰符，减少了样式冲突和依赖，使代码更易于维护和扩展。\n\n另外，再是使用`Sass/scss`、`Less`等预编译CSS库的时候。BEM能让代码逻辑清晰的同时能够更加有层次化，例如:\n\n```scss\n.button {\n  &__icon {}\n  &__text {}\n  &--active {}\n  &.disabled {}\n  &--primary {}\n  &--warning {}\n  &--info {}\n  &:not(&--disabled) {\n    &:hover {}\n    &:active {}\n  }\n  // 加载\n  &__spin {\n    &--loading {}\n  }\n}\n```\n\n---\n\n## 结论\n\nBEM 命名规范是一种有效的 CSS 命名方法，通过将样式组织成独立的块、元素和修饰符，使代码更加结构化和可维护。无论是小型项目还是大型项目，BEM 都能帮助开发者编写更清晰、更易于维护的 CSS 代码。\n\n---\n\n# 👋 ;","tags":["技术分享"]},{"title":"设计模式|发布订阅模式","url":"/2024/05/16/设计模式-发布订阅模式/","content":"\n**「奇怪？发布订阅模式并没在23种设计模式内？」**\n\n> 事实上发布订阅模式是观察者模式的一种变种，又或是说，发布订阅模式就是观察者模式。当然江湖上这个话题一直争论不休。要说区别，实际上就是发布订阅模式多了一个注册中心而已。\n\n---\n\n## ✍🏻定义\n\n所谓定义就是最枯燥，最无聊的东西。诣在把一个东西说的高大上，今天比较懒，太多字了不想写。所以就略过吧，大家可以自己意淫或者等文末看看我有没有心情总结。\n\n**「好吧，让GPT写吧」**\n\n> **🙋‍♂️Q: 发布订阅模式是什么，能讲一下定义吗？**\n>\n> > **🤖GPT:**\n> >\n> > 发布订阅模式（Publish-Subscribe Pattern）是一种消息传递模式，允许发送方（发布者）和接收方（订阅者）之间进行松耦合通信。通过这种模式，发布者不需要知道订阅者的存在，反之亦然。\n> >\n> > 发布订阅模式通过一个中介（通常称为事件总线或消息代理）来管理消息的发布和订阅。以下是该模式的核心要素：\n> >\n> > 1. **发布者（Publisher）**：发布者将消息发送到中介，而不直接发送给订阅者。发布者只需要知道消息的类型，而不需要知道谁会接收这些消息。\n> > 2. **订阅者（Subscriber）**：订阅者向中介注册自己感兴趣的消息类型。当相应的消息发布时，中介会通知所有订阅了该消息类型的订阅者。\n> > 3. **中介（Mediator/Message Broker）**：中介负责管理消息的发布和订阅。它接收来自发布者的消息，并将这些消息传递给所有订阅了该消息的订阅者。\n\n---\n\n##  ⚽️场景\n\n发布订阅模式和观察者模式在实际场景中应用的很广泛。在常用的框架内也有很多体现。例如Vue中的`watch`、`computed`; 我们常用的各种消息总线，例如: `bus总线`;Electron的IpcRenderer和IpcMain间的通信模式; 各种状态管理工具......太多了。\n\n---\n\n## ⭐️表现形式\n\n在这篇文章中，我想使用`Javascript`来展示，首先发布订阅模式是一种松耦合的设计模式。通常有两个角色：\n\n- **发布者(Publisher):** 负责发布事件或消息。\n- **订阅者(Subscriber):** 负责订阅事件或消息，并在事件发生时执行相应的操作。\n\n发布者和订阅者可以是`一对一`也可以是`一对多`关系。\n\n```javascript\nclass EventEmitter {\n    constructor() {\n        this.events = {};\n    }\n\n    // 订阅事件\n    on(event, listener) {\n        if (!this.events[event]) {\n            this.events[event] = [];\n        }\n        this.events[event].push(listener);\n    }\n\n    // 发布事件\n    emit(event, ...args) {\n        if (this.events[event]) {\n            this.events[event].forEach(listener => {\n                listener(...args);\n            });\n        }\n    }\n\n    // 取消订阅事件\n    off(event, listener) {\n        if (this.events[event]) {\n            this.events[event] = this.events[event]\n            .filter(l => l !== listener);\n        }\n    }\n}\n\n// 创建一个事件管理器实例\nconst eventEmitter = new EventEmitter();\n\n// 订阅事件\neventEmitter.on('message', data => {\n    console.log('Received message:', data);\n});\n\n// 发布事件\neventEmitter.emit('message', 'Hello, world!');\n// 输出:\n// Received message: Hello, world!\n```\n\n这就是最基本的发布订阅模式结构。再来个实际的例子吧。\n\n```javascript\nclass Child {\n    constructor(name) {\n        this.listeners = []\n        this.name = name\n    }\n\n    addListener(listener) {\n        this.listeners.push(listener)\n    }\n\n    // 广播\n    broadcast(event, msg) {\n        this.listeners.forEach(listener => {\n            if (!listener.events[event]) return\n            listener.events[event](msg)\n        })\n    }\n}\n\nclass Parent {\n    constructor(name) {\n        this.name = name\n        this.events = {}\n    }\n    on(event, callback) {\n        if (!this.events[event]) this.events[event] = callback\n    }\n}\n```\n\n一个孩子和父母的例子，父母就是孩子的订阅者。孩子就是发布者。现在我们让孩子和他的发布者发生关系。\n\n```java\nconst child = new Child('子涵');\nconst dad = new Parent('子涵爸爸');\nconst mom = new Parent('子涵妈妈');\nchild.addListener(dad);\nchild.addListener(mom);\n```\n\n这对父母的孩子很聪明，叫做子涵。一天孩子哭了。\n\n```javascript\n// 监听孩子哭了的事件\nmom.on('cry', (msg) => {\n    console.log('别哭了宝贝，妈妈这就来了')\n})\ndad.on('cry', (msg) => {\n    console.log('别哭了傻种，爸爸来打你了')\n})\n\nchild.broadcast('cry', '我好饿')\n\n// output: \n// 别哭了宝贝，妈妈这就来了\n// 别哭了傻种，爸爸来打你了\n```\n\n于是，在得到父母的关爱后，子涵立马不哭了。这就是一个发布订阅模式的例子。**孩子作为事件的发布者，维护了事件中心。父母作为事件的订阅者，监听孩子发布/广播的数据。当然，广播的粒度也可以自定义。**\n\n---\n\n好了，今天的的博客就到这吧......等我下回心血来潮了再来继续写吧。\n\n# 🫵未完待续;\n","tags":["技术分享"]},{"title":"惰性调用","url":"/2024/04/13/惰性调用/","content":"\n> 业务场景中，有些地方非常适合函数的惰性调用。利用惰性调用来优雅的实现代码的解耦合，同时也能快速的完成业务，**准备下班。**\n\n---\n\n## 介绍\n\n所谓**惰性调用**也可以说是**分步函数**或者**分段函数**，从字面意思可以看出就是将一个功能点分两个或多个步骤完成。举个简单的分段函数例子：\n\n```javascript\nconst foo = a => b => a + b \n```\n\n从这个例子能看出来，所谓分段函数就是我们通俗的讲的**闭包**，所谓闭包简单的讲就是函数内返回一个函数或者调用一个内部函数，在这个**闭包作用域**内会将变量的值锁住，即闭包内层函数可以获取到闭包外层函数的局部变量。**这个理论是我根据自己的理解瞎讲的，自认为有点说法。**\n\n### 实践一下\n\n```javascript\nconst foo = a => => a + b\n\nconst bar = foo(1)\nconsole.log(bar(1))  // 3(因为1+1=3)\n```\n\n可以看到，这个分段函数被分成了两步执行，执行第二步的时候也能获取到第一段传进来的值。这个就是简单的分段函数。\n\n---\n\n## 应用场景\n\n扯了那么多没用，实践大于理论。来个demo看看。\n\n![image-20240413211842629](../images/惰性调用.assets/image-20240413211842629.png)\n\n> 比如上面这个例子，点击列表项的选择按钮，在弹出模态框中选择合适项填充到列表项中。像这样的例子在erp系统中是非常常见的，如何使用函数惰性调用的方式来优雅的完成业务？**看接下来的操作：**\n\n```html\n<template>\n\t<div class=\"list\">\n    <div class=\"item\" v-for=\"(item, index) in arrs\" :key=\"index\">\n      <span>{{ index + 1 }}</span>\n      <span class=\"name\">{{ item.name || 'unset' }}</span>\n      <span class=\"cat\">{{ item.category || 'unset' }}</span>\n      <span class=\"xxx\">{{ item.xxx || 'unset' }}</span>\n      <!-- ...... -->\n      <button @click=\"showModal(item)\">choose</button>\n    </div>\n  </div>\n  \n <XXXSelectModal ref=\"modalRef\" @onGet=\"handleGet\"/>\n</template>\n<script setup>\n  const arrs /* 列表项 */ = ref([......])\n  let callback = null\n  const modalRef = ref(null)\n  const showModal = item => {\n    // 定义第二段函数(仅定义，不执行)\n    callback = target => {\n      // 用选中的值覆盖列表项\n      // 在此作用域中能够拿到item的值\n      Object.keys(item).forEach(key => {\n        if (!target[key]) return\n        item[key] = target[key]\n      })\n    }\n    \n    // 打开模态框\n    modalRef.value.show()\n  }\n  \n  const handleGet /* 拿到选中值 */ = (slectedValue) => {\n    // 执行第二段函数，传递第二个参数\n    callback && callback(slectedValue)\n    callback = null\n  }\n</script>\n```\n\n可以看到通过函数的分段执行，可以很轻松的实现业务的调用，这只是一个最简单的例子，在实际业务中往往会有更复杂更抽象的业务。掌握这个简单的操作可以省心很多。\n\n---\n\n## 🔺难度UP\n\n**「作为一个喜欢装逼的bugger，多少得写点让人觉得很屌的东西来展示下自己。」**\n\n函数分段执行也就是控制一个复杂函数的粒度，对于复杂函数的分段惰性操作，我们可以称之为**函数柯理化**。来点模拟业务处理的demo:\n\n> **业务1：**从这个数据中提取出所有name和age集合\n\n```javascript\n// 数据\nconst data = [{\n  name: 'Bent',\n  age: 18\n}, {\n  name: 'Jack',\n  age: 22\n}, {\n  name: 'Mike',\n  age: 33\n}]\n\n// 实现定义好提取属性值的柯里化函数\nconst getField = field => obj => obj[field]\n\nconst nameArr = data.map(getField('name'))\nconst ageArr = data.map(getField('age'))\n```\n\n当然你可以直接...\n\n```javascript\nconst ageArr = data.map(el => el.age)\nconst nameArr = data.map(el => el.name)\n```\n\n> **业务2：**根据不用场景需求来给对象数组按照字段排序\n\n```javascript\n// 数据\nconst data = [{\n  name: 'Bent',\n  age: 18,\n  balance: 2284\n}, {\n  name: 'Jack',\n  age: 22,\n  balance: 1232\n}, {\n  name: 'Mike',\n  age: 33,\n  balance: 4523\n}]\n\n\n// 提前定义好柯里化函数\nconst execSort = (field, mode = 'asc') => {\n  return (a, b) => {\n    if (mode == 'desc') return b[field] - a[field]\n    if (mode == 'asc') return a[field] - b[field]\n    return 0\n  }\n}\n\n// 按照年龄升序\ndata.sort(execSort('age'))\n// 按照年龄降序\ndata.sort(execSort('age', 'desc'))\n// 按照.....\n```\n\n当然你可以直接...\n\n```javascript\n// 按照年龄降序\ndata.sort((a, b) => b.age - a.age)\n// 按照年龄升序\ndata.sort((a, b) => a.age - b.age)\n// 按照余额降序\ndata.sort((a, b) => b.balance - a.balance)\n// 按照.....\n```\n\n> **业务3：**在每次网络请求前开启加载效果，请求结束后关闭加载效果。\n\n```javascript\n// src/utils/loading.js\n// 提前定义好工具函数并且导出\nexport const withLoading = (fn) => {\n  return (...args) => {\n    try {\n      showLoading()\n      const res = fn(...args)\n      if (res instanceof Promise) {\n        return res.then(resFix => {\n          hideLoading()\n          return resFix\n        }).catch(e => {\n          hideLoading()\n          throw e\n        })\n      }\n    } catch (e) {\n      hideLoading()\n      throw e\n    }\n  }\n}\n```\n\n在业务中引用\n\n```javascript\nimport { withLoading } from '@/utils/loading'\n\n// 伴随加载\nconst getDataWithLoading = async () => {\n  const res = await withLoading($axios.blog.getBlogById)(1)\n}\n\n// 不伴随加载\nconst getData = async () => {\n  const res = await $axios.blog.getBlogById(1)\n}\n\n// 我可以自由的控制一个异步函数是否要伴随加载效果\ngetData()\ngetDataWithLoading()\n```\n\n这时候你就会发现，用常规的方式没办法做到这么优雅的解耦，传统的方式你通常会这样实现：\n\n```javascript\nconst getDataWithLoading = async () => {\n  try {\n    showLoading()\n    const res = await $axios.blog.getBlogById(1)\n    hideLoading()\n    return res.data\n  } catch (e) {\n    hideLoading()\n    throw e\n  }\n}\n\ngetData()\n// 糟糕～每次我想要加载效果都要写这么一坨！\n```\n\n这是函数柯理化的作用就体现出来了，`withLoading`这个函数是一个纯函数，主要的作用就是给异步操作提供加载效果，它不会对作用域造成污染。还不赶紧用起来？\n\n---\n\n## 文末;\n\n函数的惰性调用能够让你和其他函数进行很好的组合工作，但是最好做到每个函数的单一职责，避免对作用域造成污染或者减少作用域污染。本文主要提供`FP(函数式编程)`的思路，让您在遇到问题的同时有一些巧妙的解决办法......如果你对函数式编程比较感兴趣的话，可以看看我之前写的文章。「[文章:函数式编程](https://bent2685.github.io/2023/12/15/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/)」在这篇文章里你会看到一些更有意思的东西。\n\n---\n\n# 👋 ;\n","tags":["技术分享","前端"]},{"title":"局部打印实现","url":"/2024/03/30/局部打印实现/","content":"\n> **引言:** 通常实现打印功能，我们会通过`window.print()`来实现，但是这个方法没办法做到局部打印，例如我想打印一个dom的内容。其实只需要做一些简单处理便可以实现打印了。 \n\n---\n\n## 方案一(🤔)\n\n> 将页面DOM临时替换成局部DOM\n\n```html\n<body>\n  <div class=\"container\">\n    <h1>Hello Word</h1>\n    <button onclick=\"printPage()\">打印页面</button>\n    <div class=\"print-area\">\n      <div class=\"content\">\n        <h2>Title</h2>\n        <p>把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。\n        </p>\n      </div>\n    </div>\n  </div>\n</body>\n```\n\n例如上方的结构，我想打印`.print-area`的内容，我可以这么操作：\n\n{% codeblock lang:javascript mark:6 %}\nconst printPage = () =>{\n  const printAreaDom = document.querySelector('.print-area')\n  const originContent /* 原始内容 */ = document.body.innerHTML\n\n  // 将页面DOM临时替换成局部DOM\n  document.body.innerHTML = printAreaDom.innerHTML\n  // 执行打印\n  window.print()\n  // 复原\n  document.body.innerHTML = originContent \n}\n{% endcodeblock %}\n\n这样做虽然能够打印出想要的内容，但是在复杂的环境下，可能会导致dom中的监听事件丢失。\n\n---\n\n## 方案二(🤩)\n\n> 使用CSS媒体查询`@print`\n\n直接贴代码:\n\n{% codeblock lang:html mark:4-6%}\n<head>\n  <style>\n    @media print {\n      :has(.print-area)> :not(.print-area):not(:has(.print-area)) {\n        display: none;\n      }\n      .print-area {\n        padding: 32px;\n      }\n    }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <h1>Hello Word</h1>\n    <button onclick=\"printPage()\">打印页面</button>\n    <div class=\"print-area\">\n      <div class=\"content\">\n        <h2>Title</h2>\n        <p>把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。把自己当傻瓜，不懂就问，你会学的更多。\n        </p>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    function printPage() {\n      window.print();\n    }\n  </script>\n</body>\n{% endcodeblock %}\n\n经过如上的媒体查询设置，`window.print()`就只会打印`.print-area`中的内容了，其他的内容就会被隐藏。它的作用是选择拥有类名为 `.print-area` 的祖先元素但不是 `.print-area` 类型的子孙元素。换句话说，它选择了所有不包含 `.print-area` 类的元素，并且这些元素的祖先元素中有包含 `.print-area` 类的元素。对于这些元素，将它们的 `display` 属性设置为 `none`，在打印时隐藏它们。***不过要注意的是**，该方法只适用于支持`:has`选择器的运行环境下，好在目前的主流浏览器都支持这个特性，应用MDN里的一句话:\n\n> Since December 2023, this feature works across the latest devices and browser versions. This feature might not work in older devices or browsers.\n>\n> 译: 自2023年12月起，此功能适用于最新设备和浏览器版本。此功能可能无法在较旧的设备或浏览器中工作。\n\n### 兼容性明细\n\n![image-20240330190658198](../images/局部打印实现.assets/image-20240330190658198.png)\n\n**「在没有IE的新时代里，放心使用」**\n\n若是对兼容性有苛刻的要求的话，可以使用成熟的三方库实现打印。在Electron、Tauri、uniapp这种跨平台框架中，应该去尝试使用像`:has`选择器这样的新花样来帮助我们的屎山代码化繁为简。\n\n---\n\n## 🔗;\n\n> [MDN对:has()选择器的介绍](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:has)\n\n---\n\n# 👋;\n","tags":["技术分享","前端"]},{"title":"前端随笔","url":"/2024/03/28/前端随笔/","content":"\n> **2024-03-28 更新**\n\n**「记录一些可爱或可癌的代码」**\n\n---\n\n## Javascript\n\n#### 两个对象间变量值的追加和覆盖\n\n- 覆盖并追加\n\n```javascript\nconst foo = { a: 1, b: 2 }\nconst bar = { b: 3, c: 4}\n\n// -> 1\nObject.keys(bar).forEach(key => {\n  foo[key] = bar[key]\n})\n\n// or 2\nconst foo2 = {...foo, ...bar}\n\nconsole.log(foo) // { a:1, b:3, c:4 }\nconsole.log(foo2) // { a:1, b:3, c:4 }\n```\n\n- 仅覆盖\n\n```javascript\nconst foo = { a: 1, b: 2 }\nconst bar = { b: 3, c: 4}\n\nObject.keys(foo).forEach(key => {\n  if (!(key in bar)) return\n  foo[key] = bar[key]\n})\n\nconsole.log(foo) // { a:1, b:3 }\n```\n\n---\n\n## CSS\n\n#### 滚动字幕\n\n给需要滚动的字幕设置`display: inline-block;`这样就可以通过`100%`相对量拿到文本的相对宽度\n\n```html\n<template>\n\t<div class=\"container\">\n  \t<p class=\"scrolling-text\">滚动字幕~~滚动字~~滚动~~滚！！！</p>\n\t</div>\n</template>\n\n<style>\n.container {\n  width: 300px;\n  overflow: hidden;\n}\n.scrolling-text {\n  + display: inline-block;\n  white-space: nowrap;\n  animation: scroll-h 10s linear infinite;\n}\n@keyframes scroll-h {\n  0% {\n    transform: translateX(0);\n  }\n  100% {\n    transform: translateX(calc(-100% + 300px));\n  }\n}\n</style>\n```\n---\n\n# 👋;\n","tags":["技术分享","前端","随笔"]},{"title":"OrbStack|好用的Docker管理","url":"/2024/03/27/OrbStack|好用的Docker管理/","content":"\n## TL;DR\n\n> 🎉 替代Docker Desktop成为你**最称手的Docker GUI**\n\n官方链接：[OrbStack](https://orbstack.dev/)\n\n**「现在开始容器启动快了，风扇也不转了」**\n\n---\n\n## 介绍\n\n作为一个**Docker GUI**能够管理容器和镜像等基础功能自然没问题，它更Docker Desktop比有着快和轻量的优势，还提供了**Kubernetes**的支持。\n\n除了Docker和k8s外，有趣的是OrbStack还给你提供了Linux虚拟机，几秒钟就可以创建出一个Linux CLI，**对开发者来说爽了是肯定的。**值得一提的是，Linux GUI也在未来计划中。\n\n![image-20240327192926032](../images/OrbStack|好用的Docker管理.assets/image-20240327192926032.png)\n\n---\n\n## Features\n\n### Docker\n\n- Docker Overview\n- Docker Networking\n- Docker卷和挂载\n\n### Kubernetes\n\n- K8s Overview\n\n### Linux虚拟机\n\n- Linux VM Overview\n- Linux CLI\n- 文件共享\n- SSH\n\n### 效率\n\n- <u>***⚡启动 FAST***</u>\n\n---\n\n# 👋 ;","tags":["应用分享","docker","工具推荐","mac系统"]},{"title":"Gogs|版本管理","url":"/2024/03/27/Gogs|版本管理/","content":"\n> 如同其[官网](https://gogs.io/)所说一款极易搭建的自助 Git 服务。它能够执行搭建git版本控制，并且在任何 [Go 语言](https://golang.org/) 支持的平台都可以运行 Gogs，包括 Windows、Mac、Linux 以及 ARM。一个廉价的树莓派的配置足以满足 Gogs 的最低系统硬件要求。有些用户甚至还将 Gogs 运行在 NAS 设备上。\n\n## TL;DR\n\n```bash\n$ docker pull gogs/gogs\n$ docker pull mysql\n$ docker network create storage\n```\n\n```bash\ndocker run -d \\\n --name mysql \\\n --env MYSQL_ROOT_PASSWORD=root123 \\\n --network=storage \\\n -p 3307:3306 \\\n --restart=always \\\n -v ~/Documents/docker/mysql/data:/var/lib/mysql \\\n mysql\n \n docker run -d \\\n --name gogs \\\n --network=storage \\\n -p 10022:22 \\\n -p 3000:3000 \\\n -v ~/Documents/docker/gogs:/data \\\n gogs/gogs\n```\n\n---\n\n## 介绍\n\nGogs拥有git技术链中的绝大多数功能，例如分支、Pull Request、工单、WIKi、分子保护、成员权限、组织、标签、Star、Fork、Watching......\n\n凭借Golang的性能优势，执行速度和资源开销这块有着明显得优势，轻量级的特点能够在绝大多数设备中跑起来。\n\n---\n\n## 安装\n\nGogs有很多种安装方式，例如：二进制安装、包管理安装、包管理安装、源码安装、**Docker安装**。本文介绍如何使用docker安装，也是我最为喜欢的方式。\n\n1. **获取镜像:**\n\n   ```bash\n   # 获取gogs镜像\n   $ docker pull gogs/gogs\n   # 获取mysql镜像\n   $ docker pull mysql\n   ```\n\n2. **创建网络(Bridge类型):**\n\n   ```bash\n   $ docker network create storage\n   ```\n\n3. **启动Mysql**\n\n   创建Mysql容器，指定root密码、网络、持久化目录、端口(也可以无需指定，看你是否有暴露到宿主机的需求)\n\n   ```bash\n   docker run -d \\\n    --name mysql \\\n    --env MYSQL_ROOT_PASSWORD=root123 \\\n    --network=storage \\\n    -p 3307:3306 \\\n    --restart=always \\\n    -v ~/Documents/docker/mysql/data:/var/lib/mysql \\\n    mysql\n   ```\n\n4. **启动gogs**\n\n   创建gogs容器，指定网络、和持久化目录，暴露3000和22端口到宿主机的3000和10022上(宿主端口自便)。\n\n   ```bash\n   docker run -d \\\n    --name gogs \\\n    --network=storage \\\n    -p 10022:22 \\\n    -p 3000:3000 \\\n    -v ~/Documents/docker/gogs:/data \\\n    gogs/gogs\n   ```\n\n5. **配置gogs:**\n\n     ![image-20240327141426902](../images/Gogs|版本管理.assets/image-20240327141426902.png)\n\t确保gogs和mysql同属于一个网络`stoage`下，使用`容器名称:端口号`的形式连接到mysql服务，在mysql中实现创建好数据库`gogs`设置utf8mb4_general_ci字符集。在配置页中输入创建好的数据库、用户名、密码，完成数据库的设置。\n\t\n\t在可选设置中的管理员账号设置中创建一个管理员账号\n\t\n\t![image-20240327141625267](../images/Gogs|版本管理.assets/image-20240327141625267.png)\n\t\n\t剩下的配置自行发挥即可，完成配置后点击立即安装。至此便完成了gogs的搭建。\n\t\n\n---\n\n# 👋 ;","tags":["技术分享","应用分享","docker","工具推荐"]},{"title":"FuncNext|1.1.4","url":"/2023/12/15/FuncNext-1-1-4/","content":"\n> FuncNext 1.1.4\n\n## 安装\n```bash\nnpm install func-next --save-dev\n```\n\n---\n\n## 介绍\n是一个 JavaScript 类。它提供了一些方法，可以对一个对象进行一系列的操作，包括：\n- 深拷贝对象\n- 排除指定的属性\n- 执行一系列函数\n- 覆盖或追加对象的属性\n- 选择指定的属\n- 删除指定的属性\n- 将日期转换为时间戳\n- 将日期转换为任意格式\n- 对对象的每个属性执行指定的函数\n- 这个类的作用是提供一种方便的方式来操作对象，可以用于数据处理、数据转换等场景。使用这个类可以避免手动编写大量的代码来完成这些操作，提高开发效率。\n\n如果要使用这个类，可以通过 import 语句将它引入到你的代码中，然后创建一个 FuncNext 的实例，调用它提供的方法来对对象进行操作。\n\n---\n\n## 使用方法\n\n```javascript\nimport FuncNext from 'func-next';\n\nconst obj = {\n  name: 'Alice',\n  age: 20,\n  gender: 1,\n  bornDate: '2003-06-03'\n};\n\n// 深拷贝\nconst newObj = FuncNext.of(obj).out()\n\n// 对象每个键设为指定值\nconst newObj = FuncNext.of(obj).map(x => null).out()\n// newObj = { name: null, age: null, gender: null, bornDate: null }\n\n// 保护(排除)指定键\nconst newObj = FuncNext.of(obj).exclude('name').map(x => null).out()\n// newObj = { name: 'Alice', age: null, gender: null, bornDate: null };\nconst newObj = FuncNext.of(obj).exclude('name', 'age').map(x => null).out()\n// newObj = { name: 'Alice', age: 20, gender: null, bornDate: null }\n\n// 覆盖或新增\n//! 受保护的键不会被修改\nconst newObj = FuncNext.of(obj).coverOrAppend({name:'jack', address: 'xxx'}).out()\n// newObj = { name: 'jack', age: 20, gender: 1, bornDate: '2003-06-03', address: 'xxx' }\n\n// 提取指定key组成新对象\n//! 受保护的键也会被pick\nconst newObj = FuncNext.of(obj).pick('name', 'age').out()\n// newObj = { name: 'Alice', age: 20 }\n\n// 移除指定键\n//! 受保护的键不会被移除\nconst newObj = FuncNext.of(obj).takeOut('name', 'age').out()\n// newObj = { gender: 1, bornDate: '2003-06-03'}\n\n// 把与日期有关的值都转为时间戳\n//! 受保护的键不会被转换\nconst obj = {\n  name: 'Alice',\n  age: 20,\n  bornDate: '2003-06-03',\n  createTime: new Date()\n};\nconst newObj = FuncNext.of(obj).dateToTimestamp().out()\n// newObj = { name: 'Alice', age: 20, bornDate: 1054598400000, createTime: 1686479418509 }\n\n// 把与日期有关的所有值都转换为自定义格式\n//! 受保护的键除外\n//* 结合dayjs等库使用，将是最佳实践\n// 注意dateToAnyFormat接收一个T => R函数, 别忘了Return\nconst obj = {\n  name: 'Alice',\n  age: 20,\n  bornDate: '2003-06-03',\n  createTime: new Date()\n};\nconst newObj = FuncNext.of(obj).dateToAnyFormat(x => null).out()\n// newObj = { name: 'Alice', age: 20, bornDate: null, createTime: null }\n\n// 遍历获取每个值\n//！ 受保护的键不会被遍历\n// 常用于修改, 别忘了return\n// 接收一个(value, key) => newValue\nconst newObj = FuncNext.of(obj).map((value, key) => {\n    if (key != 'name') return null\n    return value\n}).out()\n// newObj = { name: 'Alice', age: null, gender: null, bornDate: null }\n\n// 遍历获取每个值\n//！受保护的键也会被遍历\n// 用于消费，请勿用来修改值\n// 接受一个Consumer函数, 即(value, key, isProtected:是否受保护) => void\nFuncNext.of(obj)\n    .exclude('gender')\n    .each((value, key, isProtected) => {\n        console.log(`值: ${value}, 键: ${key}, 是否受保护: ${isProtected}`)\n    }).out()\n// 值: Alice, 键: name, 是否受保护: false\n// 值: 20, 键: age, 是否受保护: false\n// 值: 1, 键: gender, 是否受保护: true\n// 值: 2003-06-03, 键: bornDate, 是否受保护: false\n```\n\n---\n\n## 注意\n\n**`of()`和`out()`是 FuncNext 类中的两个起始方法。**\n\nof() 方法用于创建一个 FuncNext 实例，它接受一个对象作为参数，并返回一个 FuncNext 实例，可以通过这个实例来对对象进行一系列的操作。\n\nout() 方法用于获取操作后的结果，它会返回一个新的对象，这个对象是经过 FuncNext 实例中的所有操作后得到的结果。需要注意的是，out() 方法并不会修改原始对象，而是返回一个新的对象。\n\n在 FuncNext 的链式调用中，通常会在 of() 方法后面调用一系列的方法来对对象进行操作，最后再调用 out() 方法来获取操作后的结果。\n\n---\n\n## 仓库地址\n[![badge](https://img.shields.io/badge/github-FuncNext-%23036aa4)](https://github.com/bent2685/func-next)\n","tags":["开源","开发库"]},{"title":"设计模式|策略模式","url":"/2023/12/15/设计模式-策略模式/","content":"\n> **策略模式(Strategy Pattern)**是一种软件设计模式，属于行为型模式。它允许在运行时根据不同情况选择算法的行为。\n\n---\n\n##  ✍🏻定义\n\n在策略模式中，将各种算法封装成不同的策略（Strategy），并使它们可以互相替换。每个策略都完成一个特定的任务，但是它们的接口是相同的，这样业务就可以在不知道具体实现的情况下使用不同的策略。\n\n---\n\n## 🍭优点\n\n1. 提供了更好的代码重用性，可以通过增加新的策略类来扩展系统功能，而不需要修改原有代码。\n2. 提供了更好的扩展性，可以方便地增加新的策略，满足不同的需求。\n3. 可以避免使用大量的条件语句，提高了代码的可读性和可维护性。\n\n---\n\n## 组成成员\n\n### 策略接口(Strategy Interface)\n\n策略接口定义了策略模式的公共接口。它通常包含一个或多个方法，用于执行特定的算法或操作。所有的具体策略类都必须实现这个接口，以确保它们具有相同的方法签名。\n\n### 具体策略类(Concrete Strategies)\n\n具体策略类实现了策略接口，并封装了具体的算法或操作。每个具体策略类提供了不同的实现，用于完成特定的任务。客户端可以根据需求选择不同的具体策略类。\n\n### 上下文类(Context)\n\n上下文类是策略模式的核心组件，它持有一个策略对象的引用，并在需要执行特定算法或操作时调用策略对象的方法。上下文类通常包含一个设置策略的方法，用于在运行时动态地切换策略。\n\n### 客户端(Client)\n\n客户端是使用策略模式的调用者。它通过实例化上下文类并设置具体策略对象来选择要使用的算法或操作。客户端根据自身的需求，在不同的情况下选择不同的策略，从而实现灵活的算法切换。\n\n---\n\n## 📖经典例子\n\n我们使用java来写一个贴切实际业务的策略模式的例子\n\n### 支付策略接口\n\n```java\npublic interface PaymentStrategy {\n  void pay(double amount);\n}\n```\n\n### 具体策略类\n\n#### 信用卡支付\n\n```java\npublic class CreditCardPaymentStrategy implements PaymentStrategy {\n  private String cardNumber;\n  private String expirationDate;\n  private String cvv;\n\n  public CreditCardPaymentStrategy(String cardNumber, String expirationDate, String cvv) {\n    this.cardNumber = cardNumber;\n    this.expirationDate = expirationDate;\n    this.cvv = cvv;\n  }\n\n  @Override\n  public void pay(double amount) {\n    // 使用信用卡进行支付的逻辑\n    System.out.println(\"支付 ￥\" + amount + \" 通过信用卡号: \" + cardNumber);\n    // 其他支付操作...\n  }\n}\n```\n\n#### 支付宝支付\n\n```java\npublic class AlipayPaymentStrategy implements PaymentStrategy {\n  private String userId;\n  private String password;\n\n  public AlipayPaymentStrategy(String userId, String password) {\n    this.userId = userId;\n    this.password = password;\n  }\n\n  @Override\n  public void pay(double amount) {\n    // 使用支付宝进行支付的逻辑\n    System.out.println(\"支付 ￥\" + amount + \" 通过支付宝账户: \" + userId);\n    // 其他支付操作...\n  }\n}\n```\n\n### 上下文类\n\n```java\npublic class Order {\n  private double amount;\n  private PaymentStrategy paymentStrategy;\n\n  public Order(double amount, PaymentStrategy paymentStrategy) {\n    this.amount = amount;\n    this.paymentStrategy = paymentStrategy;\n  }\n  \n  public void makePayment() {\n    paymentStrategy.pay(amount);\n  }\n}\n```\n\n### 客户端\n\n```java\npublic class Main {\n  public static void main(String[] args) {\n    // 创建订单\n    Order order1 = new Order(100.0, new CreditCardPaymentStrategy(\"1234 5678 9012 3456\", \"12/25\", \"123\"));\n    Order order2 = new Order(200.0, new AlipayPaymentStrategy(\"user123\", \"password456\"));\n\n    // 执行支付\n    order1.makePayment();\n    System.out.println();\n    order2.makePayment();\n  }\n}\n```\n\n### 输出结果\n\n```yaml\n# output\n支付 ￥100.0 通过信用卡号: 1234 5678 9012 3456\n\n支付 ￥200.0 通过支付宝账户: user12\n```\n\n---\n\n### 小结\n\n结合上述例子，可以得出结论:\n\n> 策略接口定义了策略模式的公共接口，具体策略类实现了该接口并封装了具体的策略算法。上下文类持有策略对象并在需要时调用其方法，而客户端则负责创建具体策略对象并将其传递给上下文类。这样，客户端可以根据不同的情况选择不同的策略，并将其应用于上下文类的操作中。\n\n当业务需要更多执行策略的时候，只需创建具体策略类(继承策略公共接口)即可，例如:\n\n```java\n// 微信支付策略\npublic class WeChatPaymentStrategy implements PaymentStrategy {\n  private String appId;\n  private String appSecret;\n\n  public WeChatPaymentStrategy(String appId, String appSecret) {\n    this.appId = appId;\n    this.appSecret = appSecret;\n  }\n\n  @Override\n  public void pay(double amount) {\n    // 使用微信支付的逻辑\n    System.out.println(\"支付 ￥\" + amount + \" 通过微信APP ID: \" + appId);\n    // 其他支付操作...\n  }\n}\n```\n\n且在具体执行逻辑中\n\n```java\npublic class Main {\n  public static void main(String[] args) {\n    // 创建订单\n    Order order1 = new Order(100.0, new CreditCardPaymentStrategy(\"1234 5678 9012 3456\", \"12/25\", \"123\"));\n    - Order order2 = new Order(200.0, new AlipayPaymentStrategy(\"user123\", \"password456\"));\n    + Order order2 = new Order(150.0, new WeChatPaymentStrategy(\"12345678\", \"a1b2c3d4\"));\n    // 执行支付\n    order1.makePayment();\n    System.out.println();\n    order2.makePayment();\n  }\n}\n```\n\n结果\n\n```yaml\n# output\n支付 ￥100.0 通过信用卡号: 1234 5678 9012 3456\n\n支付 ￥150.0 通过微信AOO ID: 12345678\n```\n\n在本例中，业务的替换或拓展通过策略模式的优化将逻辑业务转到了策略类中，降低了工程的耦合度和可维护性。\n\n---\n\n## 🍺枚举策略\n\n> **🙋🏻‍♂️问:**\n>\n> 策略模式的每次扩展都需要添加策略类，随着业务的不断扩展，显然这是一个弊端。能否解决这个问题呢？\n>\n> > **💡当然可以！**\n> >\n> > 我们可以使用枚举策略\n\n---\n\n### 集合策略接口、具体策略类、上下文类\n\n> **我们可以通过枚举的特性来优化**\n>\n> 枚举类中的抽象方法的实现，需要枚举类中的每个元素都对其进行实现。\n\n```java\n// 策略枚举\npublic enum PaymentStrategy {\n  CREDIT_CARD {\n    @Override\n    public void pay(double amount) {\n      // 使用信用卡进行支付的逻辑\n      System.out.println(\"支付 ￥\" + amount + \" 通过信用卡\");\n      // 其他支付操作...\n    }\n  },\n  ALIPAY {\n    @Override\n    public void pay(double amount) {\n      // 使用支付宝进行支付的逻辑\n      System.out.println(\"支付 ￥\" + amount + \" 通过支付宝\");\n      // 其他支付操作...\n    }\n  },\n  WECHAT {\n    @Override\n    public void pay(double amount) {\n      // 使用微信支付的逻辑\n      System.out.println(\"支付 ￥\" + amount + \" 通过微信\");\n      // 其他支付操作...\n    }\n  };\n\n  public abstract void pay(double amount);\n}\n```\n\n此时枚举类中的每个元素代表的即是一个策略\n\n```java\npublic class Main {\n  public static void main(String[] args) {\n    double amount = 100.0;\n\n    // 使用信用卡进行支付\n    PaymentStrategy.CREDIT_CARD.pay(amount);\n\n    // 使用支付宝进行支付\n    PaymentStrategy.ALIPAY.pay(amount);\n\n    // 使用微信支付\n    PaymentStrategy.WECHAT.pay(amount);\n  }\n}\n```\n\n```yaml\n# output\n支付 ￥100.0 通过信用卡\n支付 ￥100.0 通过支付宝\n支付 ￥100.0 通过微信\n```\n\n> **🙋🏻‍♂️问:**\n>\n> 有没有办法可以通过业务传递的动态值来选择策略(而不是写死在程序上)?\n>\n> > **💡当然可以！**\n> >\n> > 我们可以通过枚举的`valueOf`方法\n\n```java\npublic class Main {\n  public static void main(String[] args) {\n    double amount = 100.0;\n\n    // 动态选择枚举值\n    String paymentMethod = \"WECHAT\";\n    PaymentStrategy strategy = PaymentStrategy.valueOf(paymentMethod);\n\n    // 执行支付\n    strategy.pay(amount);\n  }\n}\n```\n\n```yaml\n# output\n支付 ￥100.0 通过微信\n```\n\n---\n\n## ✨使用函数式接口优化策略模式\n\n> 在Java8中引入了函数式编程概念以及Lambda表达式\n\n### 定义函数式接口\n\n```java\n@FunctionalInterface\ninterface PaymentStrategy {\n  void pay(double amount);\n}\n```\n\n### 具体业务实现\n\n```java\npublic class Main {\n  public static void main(String[] args) {\n    double amount = 100.0;\n\n    // 使用Lambda表达式定义不同的支付策略\n    PaymentStrategy creditCardStrategy = (amt) -> {\n      // 支付操作...\n    };\n\n    PaymentStrategy alipayStrategy = (amt) -> {\n      // 支付操作...\n    };\n\n    PaymentStrategy wechatStrategy = (amt) -> {\n      // 支付操作...\n    };\n\n    // 执行支付\n    creditCardStrategy.pay(amount);\n    alipayStrategy.pay(amount);\n    wechatStrategy.pay(amount);\n  }\n}\n```\n\n---\n\n##  💥注意\n\n如果业务**只有一个或很少数的分支行为，又或者是无需持续维护或拓展分支功能的业务**，那或许该考虑是否适合用策略模式。\n\n> 🙅🏻‍♂️**请不要为了使用设计模式而尬写设计模式！**\n>\n> 🙅🏿‍♂️**请不要为了使用设计模式而尬写设计模式！**\n>\n> 🙅‍♂️**请不要为了使用设计模式而尬写设计模式！**\n>\n> > 🙎🏻: **我测**\n\n---\n\n## 🎍扩展\n\n当然同一个业务下，不同策略类也会有重复的流程，可以结合`模板方法设计模式`来优化业务的耦合部分，提高可维护性。\n\n---\n\n## 总结\n\n> 策略模式是一种行为设计模式，它允许在运行时根据不同的情况选择算法或行为。该模式将算法封装在独立的策略类中，并通过一个上下文类将客户端与具体的策略解耦。客户端可以动态地选择所需的策略，而无需了解其具体实现。\n>\n> **策略模式可以优化代码中的分支语句。**传统的条件语句（如if-else或switch）在算法逻辑较多或复杂时，容易导致代码臃肿、难以维护。而策略模式通过将不同的算法封装成独立的策略类，使得代码更加清晰、可读性更强，并且易于扩展。\n>\n> **合理的使用策略模式可以提高业务代码的可维护性。**使得代码更加清晰、可读性更强，并且易于扩展。\n\n**🛵ENDING**...(开走了)\n","tags":["技术分享"]},{"title":"函数式编程","url":"/2023/12/15/函数式编程/","content":"\n> **引言：**函数式编程(Functional Programming)，简称 FP，是一种编程范式。\n>\n> 它将电脑运算视为函数运算，并且避免使用程序状态以及易变对象。其中，lambda演算为该语言最重要的基础。而且，lambda演算的函数可以接受函数当作输入（引数）和输出（传出值）。\n>\n> 比起指令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。\n\n---\n\n## 纯函数\n\n> **概念：**即相同的输入，永远会得到相同的输出，而且没有任何可观察的**副作用**。\n\n所谓纯函数有两个重要概念：\n\n- **无副作用**\n\n  纯函数在执行过程中不会对除函数返回值以外的任何东西产生影响。这意味着它不会改变任何全局变量、不会修改传入的参数，也不会产生除了返回值以外的其他可观察到的影响。\n\n- **相同输入产生相同输出**\n\n  给定相同的输入，纯函数总是返回相同的输出，不受任何外部因素影响。这使得纯函数更容易进行测试和推理，因为其行为是可预测和确定的。\n\n---\n\n### 例子\n\n```javascript\n//* 非纯函数\n// 污染外部变量\nconst baseNum = 10\nconst add = (num) => {\n    return baseNum + num\n}\n\n//* 纯函数\n// 没有污染外部变量\nconst add = (num) => {\n    const baseNum = 10\n    return baseNum + num\n}\n\nconst arr = [1, 2, 3, 4, 5, 6]\n//* 非纯函数\narr.splice(0, 3)\n// => [1, 2, 3]\n// 改变原了数组\n\n//* 纯函数\narr.slice(0, 3)\n// => [1, 2, 3]\n// 返回新数组，不改变原数组\n```\n\n---\n\n### 好处\n\n1. **可预测性：** 纯函数的输出只依赖于输入参数，因此对于相同的输入始终产生相同的输出。这种确定性使代码更易于测试和推理。\n2. **可缓存性：** 纯函数对于相同的输入始终返回相同的结果，因此可以利用缓存来提高性能，避免重复计算。\n3. **可并行性：** 由于纯函数不涉及共享状态，因此可以更容易地并行执行，无需担心竞争条件或锁的问题。\n4. **更容易推理：** 纯函数不依赖于外部状态，使得代码更容易推理和理解，减少了出错的可能性\n\n---\n\n## 闭包\n\n> 闭包是一类特殊的高阶函数，它是由函数和其周围状态的引用捆绑在一起形成的，它的表现就是可以在一个作用域中**调用一个函数内部的函数并访问到该函数的作用域中的成员**。\n>\n> 闭包形成的原因是，当一个函数执行完成以后，其**内部的成员就会被释放掉**。如果这个**函数返回了一个函数**，并且在这个返回的函数**内部又访问了其外部函数中的成员变量**，这就形成了闭包。即**外部对内部成员有引用，就造成该成员不能被释放掉**。\n\n### 特点\n\n- **在一个作用域中可以去调用另一个函数的内部函数**\n\n- **调用这个内部函数的时候可以访问到这个内部函数外部函数的内部成员**\n\n```javascript\n// 计算工资函数\nconst calcSalary = base => {\n    return (/* 表现工资 */ perf) => {\n      \t// 内部函数可以访问到外部函数(calcSalary)的base变量\n        return base + perf\n    }\n}\n\nconst getSalaryOfDeveloper = calcSalary(12000)\nconst getSalaryOfManager = calcSalary(15000)\n\n// 在一个作用域中调用函数的内部函数\nconst mikeSalary = getSalaryOfDeveloper(2000)\n// ==> 14000 \nconst amySalary = getSalaryOfDeveloper(3000)\n// ==> 15000\nconst jackSalary = getSalaryOfManager(3000)\n// =>> 18000\n```\n\n---\n\n## 惰性调用\n\n> **概念：**延迟表达式的求值直到实际需要的时候。这意味着表达式不会在定义时立即被计算，而是在需要其值的时候才被求值和执行。\n\n在函数式编程中，惰性计算经常用于创建无限序列或避免不必要的计算。这种方法允许程序在必要的时候才执行计算，以节省资源并提高效率。\n\n### 例子\n\n```javascript\n// 计算工资函数\nconst calcSalary = base => {\n    return perf => base + perf\n}\n\n// 给予参数，但不立即执行\nconst getSalaryOfDeveloper = calcSalary(12000)\n\n// 当需要结果时，才调用函数进行计算\nconst mikeSalary = getSalaryOfDeveloper(2000)\n```\n\n```javascript\n// 惰性调用在正则中的例子\nconst createRegExpTemplate = (regStr) => {\n    const reg = new RegExp(regStr)\n    return (testValue) => reg.test(testValue)\n}\nconst emailRegExp = createRegExpTemplate('^\\\\w+@[a-z0-9]+\\\\.[a-z]+$')\nconst phoneRegExp = createRegExpTemplate('^1[34578]\\\\d{9}$')\n\nconsole.log(emailRegExp('111.com'))\n// ==> false\nconsole.log(emailRegExp('helloword123@qq.com'))\n// ==> true\nconsole.log(phoneRegExp('17312341234'))\n// ==> true\n```\n\n---\n\n## 柯理化\n\n> 柯里化是一种将使用**多个参数的函数**转换成**一系列使用一个参数的函数**的技术。它的核心思想是将一个接受多个参数的函数转换为一系列嵌套的单参数函数。\n\n### 展现形式\n\n柯理化函数是建立在闭包和惰性调用的基础之上的一个概念，有了这两个理念的支持才得以实现函数柯理化。\n\n```javascript\n// 普通函数\nconst add = (a, b, c) => a + b + c\n//* 柯理化函数\n// 一些列一个参数的函数\nconst add = a => b => c => a + b + c\n\nconsole.log(add(1)(2)(3))\n// => 6\nconst addBase = add(100)(10)\nconsole.log(addBase(5))\n// => 115\nconsole.log(addBase(8))\n// => 118\n```\n\n### 作用\n\n> 多个参数的函数转换为一系列接受单个参数的函数。这种转换使得函数更加灵活、更易于复用，并且支持更为简洁的函数组合。\n\n### 参数复用与部分应用\n\n柯里化允许您先传递一部分参数，然后在后续调用中提供剩余参数。这对于创建更多抽象的函数非常有用。\n\n```javascript\nfunction calculateTax(taxRate) {\n  return function(amount) {\n    return amount * taxRate\n  };\n}\n\n// 创建一个计算5%税率的函数\nconst apply5PercentTax = calculateTax(0.05)\n\nconst res = apply5PercentTax(100)\nconst res2 = apply5PercentTax(200)\n\n```\n\n由于闭包和惰性执行的特性，柯理化函数把一个业务流程颗粒化成一系列的小粒度业务。可以随着流程的变化惰性的赋予其他参数，让这个业务可以随着代码的执行流程变得非常可控，是函数式编程中非常重要的组成。\n\n### 柯理化工厂\n\n```javascript\nconst curryFactory = (fn) => {\n    const curried = (...args) => {\n        if (args.length >= fn.length) {\n            return fn(...args)\n        } else {\n            return (...moreArgs) => curried(...args, ...moreArgs)\n        }\n    };\n    return curried\n}\n```\n\n我们并不可能对多参数函数手动的实现它的柯理化，但是我们可以借助柯理化工厂来实现。\n\n```javascript\n// 示例函数\nconst add = (a, b, c) => a + b + c;\n\n// 创建柯里化版本\nconst curriedAdd = curryFactory(add);\n\n// 使用柯里化函数\nconsole.log(curriedAdd(2)(3)(4)) // 输出: 9\nconsole.log(curriedAdd(2, 3)(4)) // 输出: 9\nconsole.log(curriedAdd(2)(3, 4)) // 输出: 9\nconsole.log(curriedAdd(2, 3, 4)) // 输出: 9\n```\n\n---\n\n## 组合(Compose)\n\n> 数组合是函数式编程中的一个重要概念，它涉及将多个函数结合在一起，形成一个新的函数。这种组合允许你以一种清晰、模块化的方式构建复杂的操作。\n\n### 展现形式\n\n在函数组合中，两个或多个函数按照一定的顺序合并在一起，使得每个函数的输出成为下一个函数的输入，从而形成一个新的函数。这种组合可以简化代码、提高可读性，并且可以减少中间变量的使用。**一个简单的例子：**\n\n```javascript\n// 简单的组合函数工厂\nconst compose = (f, g) => x => f(g(x))\n\n// 两个纯函数\nconst add5 = x => x + 5\nconst multiply = (x) => x * 2\n\n// 组合函数并按顺序执行\nconst res = compose(add5, multiply)(10)\nconsole.log(res)\n// => 25\n```\n\n从这个简单的例子可以发现，函数组合其实就是字面意思，将多个函数组合在一起形成一个新的函数，当组合多的时候，纯函数的特点就体现出来的。这就是为什么函数式编程提倡纯函数，提倡无作用函数的重要原因。\n\n### 多函数组合\n\n往往我们需要组合多个纯函数，那上面的简单组合工厂就不适用了，稍作调整：\n\n```javascript\nconst compose = (...fns) => (x) => {\n    return fns.reduceRight((acc, fn) => fn(acc), x);\n}\n\nconst add5 = x => x + 5\nconst multiply = x => x * 2\nconst desc10 = x => x - 10\n\nconst res = compose(add5, multiply, desc10)(10)\nconsole.log(res)\n// => 5\n```\n\n---\n\n## 管道(Pipe)\n\n> 管道(Pipe)，它很类似于组合。但更强调数据的流动和函数的串联，不会创建新的函数。\n\n### 展现形式\n\n函数管道强调数据流向的方向，一个函数的输出成为下一个函数的输入，从而形成一个数据流水线。**一个简单的例子：**\n\n```javascript\nconst add5 = (x) => x + 5\nconst multiply = (x) => x * 2\n\nconst res = multiply(add5(3))\nconsole.log(res)\n// => 16\n```\n\n可以看到它和组合的展现形式有所不同，它是从前往后，而非从而往前。和组合比调换了执行顺序，也就是说：\n\n```javascript\n// 从\nconst compose = (f, g) => x => f(g(x))\n// 变为\nconst pipe = (f, g) => x => g(f(x))\n```\n\n### 管道和组合的区别\n\n在广义上，管道和组合其实是同一个作用，它们都是把多个函数组合在一起来执行一系列的操作。它们的实现方式可能有些微小的差别，主要在于函数执行顺序上，组合通常从右到左执行函数，而管道通常从左到右执行函数。很多时候甚至都不对它们不做区分，只不过从语义上对它们的职责进行了分化，从而导致叫法不同。例如，通常组合不会组合很多的函数，当组合的函数多了，我们可以称之为管道。\n\n---\n\n## 函子(Functor)\n\n> 在函数式编程中，函子（Functor）是一种特殊的对象或数据结构，它实现了 map 函数，并遵循一些特定规则。函子可被视为一种抽象，它提供了一种包装值的机制，并允许对这些值进行变换和操作，而无需直接暴露内部实现。\n\n### 特点\n\n函子的主要特点是它具有一个 `map` 方法，这个方法能够将函子中的值映射到另一个函子中。当对函子调用 `map` 方法时，它会返回一个新的函子，而不是直接操作原始值。\n\n函子的实现可以是各种类型的数据结构，例如数组、对象、甚至 Promise。这种抽象允许我们对值进行变换、映射或其他操作，而无需直接访问或修改值。\n\n### 规则\n\n- **对值进行包装**\n- **提供`map`方法：** 函子必须提供 `map` 方法，这个方法能够对函子内的值进行操作并返回一个新的函子。\n- **保持对原值的不可变性：**`map` 方法对值进行操作时，不会直接修改原始值，而是返回一个新的函子包含了新值。\n- **遵循同态性：** `map` 方法保持了函子对值的变换，并且可以链接多次 `map` 调用而不改变函子的结构。\n\n### 具体形式\n\n#### Pointed函子\n\n实现了`of`静态方法的函子被称为**Pointed函子**，未实现的则为普通函子。\n\n```javascript\nclass Pointed {\n  constructor(value) {\n    // 私有\n    this._value = value\n  }\n\n  // 契约的map方法\n  map(fn) {\n  \t// fn: 传入的纯函数\n    return Pointed.of(fn(this._value))\n  }\n\n  static of(value) {\n    return new Pointed(value)\n  }\n}\n\nlet num = Pointed.of(10).map(x => x + 1).map(x => x * 2)\n```\n\n#### Maybe函子\n\n> Maybe 会先检查自己的值是否为空，然后才调用传进来的函数，这样处理空值就不会出错了。Maybe 常用在那些可能无法成功返回结果的函数中；可以避免使用命令式的 if...else 语句，可以用 Maybe(null) 来表示失败，但却不能告诉我们太多有效信息，譬如：失败的原因是什么？是哪儿造成失败的？Either 函子能帮助我们解决这样的问题。\n\n```javascript\nclass Maybe {\n  static of (value) {\n    return new Maybe(value)\n  }\n\n  constructor (value) {\n    this._value = value\n  }\n\n  map (fn) {\n    // 检查自己的值是否为空\n    return this._value ? Maybe.of(fn(this._value)) : Maybe.of(null)\n  }\n}\n\nlet toUpper = Maybe.of(null).map(x => x.toUpperCase())\n\n// 输出：Maybe { _value: null }\nconsole.log(toUpper)\n\n// 用在可能会无法成功返回结果的函数中\nfunction getFirst (arr) {\n  return Maybe.of(arr[0])\n}\nlet firstElement = getFirst([]).map(x => x + 3)\n// 输出：Maybe { _value: null }\nconsole.log(firstElement)\n```\n\n#### Either函子\n\n> 函数式编程里面，使用 Either 函子代替条件运算（if...else）；另一个用途是代替 try...catch，使用左值表示错误。\n\n```javascript\nclass Left {\n  static of(value) {\n    return new Left(value)\n  }\n  constructor (value) {\n    this._value = value\n  }\n  map (fn) {\n    return this\n  }\n}\n\nclass Right {\n  static of (value) {\n    return new Right(value)\n  }\n  constructor (value) {\n    this._value = value\n  }\n  map (fn) {\n    return Right.of(fn(this._value))\n  }\n}\n```\n\n上面所述就是**Either函子**：Left表示错误函子，Right表示正确函子。**Either函子**通常用于函数的返回值例如：\n\n```javascript\nconst isEven = x => x % 2 === 0\n    ? Right.of(x)\n    : Left.of('not even')\n\nisEven(2).map(console.log)\n// ==> 输出：2\n\nisEven(3).map(console.log)\n// ==> 不输出\n```\n\n如上例子，将函数的返回值改为Either函子，函数满足您的逻辑正确，则执行Right函子的map反之则执行Left函子的map语句(直接返回当前实力，也就是说被截断。)\n\n那么，又如何判断函数返回的函子是Right还是Left呢？**两种方法：**\n\n- **标记函子**\n\n  这个方法简单粗暴，给对应Either函子一个标识即可。\n\n  ```javascript\n  class Left {\n    \n    isLeft() { return true }\n    isRight() { return false }\n    \n    static of(value) {\n      return new Left(value)\n    }\n    constructor (value) {\n      this._value = value\n    }\n    map (fn) {\n      return this\n    }\n  }\n  \n  class Right {\n    isLeft() { return false }\n    isRight() { return true }\n    \n    static of (value) {\n      return new Right(value)\n    }\n    constructor (value) {\n      this._value = value\n    }\n    map (fn) {\n      return Right.of(fn(this._value))\n    }\n  }\n  \n  const isEven = x => x % 2 === 0\n      ? Right.of(x)\n      : Left.of('not even')\n  \n  const resFunctor = isEven(2)\n  if (resFunctor.isRight()) {\n    resFunctor.map(console.log)\n  } else {\n    // 执行错误逻辑\n  }\n  ```\n\n  这种传统方式，不够灵活，可以试试使用**fold方法**来解决问题\n\n- **fold方法**\n\n  ```javascript\n  class Left {\n      static of(value) {\n          return new Left(value);\n      }\n  \n      constructor(value) {\n          this._value = value\n      }\n  \n      map(fn) {\n          return this\n      }\n  \n      fold(leftFn, rightFn) {\n          return leftFn(this._value)\n      }\n  }\n  \n  class Right {\n      static of(value) {\n          return new Right(value)\n      }\n  \n      constructor(value) {\n          this._value = value\n      }\n  \n      map(fn) {\n          return Right.of(fn(this._value))\n      }\n  \n      fold(leftFn, rightFn) {\n          return rightFn(this._value);\n      }\n  }\n  \n  const isEven = x => x % 2 === 0\n      ? Right.of(x)\n      : Left.of(`error: ${x} is not even`)\n  \n  isEven(2).fold(\n      // 直接输出错误信息\n      console.log,\n      x => {\n          console.log(`${x} 为偶数，做一些额外处理`)\n          // ......\n      }\n  )\n  // => 2 为偶数，做一些额外处理\n  // => .....其他额外处理输出\n  ```\n\n  如果对错误事件想要进行额外的特殊处理，改怎么办？\n\n  无需变动上方代码，将特殊处理的逻辑传给`leftFn`即可。\n\n  ```javascript\n  isEven(3).fold(\n      // 直接输出错误信息\n      () => {\n        console.log(`${x} 不为偶数，做一些额外特殊处理`)\n        // ......\n      },\n      x => {\n          console.log(`${x} 为偶数，做一些额外处理`)\n          // ......\n      }\n  )\n  // => 3 不为偶数，做一些额外特殊处理\n  // => .....其他额外处理输出\n  ```\n\n  这样就可以很优雅的处理分支和异常\n\n### 函子的使用\n\n> 通过函子实现链式编程，以及异常处理\n\n- 所用函子\n\n  ```javascript\n  const Either = {\n      Left: (value) => ({\n          map: (fn) => Either.Left(value),\n          fold: (fn, _) => fn(value),\n          chain: (fn) => Either.Left(value)\n      }),\n      Right: (value) => ({\n          map: (fn) => Either.Right(fn(value)),\n          fold: (_, fn) => fn(value),\n        \t//+ 用于保持函子的结构\n          chain: (fn) => fn(value)\n      })\n  }\n  ```\n\n- 业务\n\n  ```javascript\n  // 是否为偶数\n  const isEven = (n) => n % 2 === 0\n      ? Either.Right(n)\n      : Either.Left(n)\n  // 是否大于2\n  const isBiggerThan2 = (n) => n > 2\n  \t\t? Either.Right(n)\n      : Either.Left(n)\n  // 减半\n  const half = (n) => n / 2\n  \n  const result = isEven(10)\n      .chain(isBiggerThan2)\n      .map(half)\n      .map((n) => n + 2)\n      .fold(() => 0, n => n)\n  console.log(result)\n  // => 7\n  \n  const result2 = isEven(2)\n      .chain(isBiggerThan2)\n      .map(half)\n      .map((n) => n + 2)\n      .fold(() => 0, n => n)\n  console.log(result2)\n  // => 0\n  \n  const result3 = isEven(1)\n      .chain(isBiggerThan2)\n      .map(half)\n      .map((n) => n + 2)\n      .fold(() => 0, n => n)\n  console.log(result3)\n  // => 0\n  ```\n\n  可以发现，当中途出现，`Either.Left`时，就会将`Either.Right.map()`更改为`Either.Left.map()`，也就是说不对值执行map中传递的纯函数返回函子本身(等价于跳过)，最终被`Either.Left.fold()`劫持到。\n\n> 另外，类似这样的函子还有一些，例如：Ap函子、IO函子、Monad函子。通过上面所述的函子，可以得出，函子它具有一个 `map` 方法，这个方法能够将函子中的值映射到另一个函子中。当对函子调用 `map` 方法时，它会返回一个新的函子，而不是直接操作原始值。\n\n---\n\n# 👋 保重;\n","tags":["技术分享"]}]